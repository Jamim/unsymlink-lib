#!/usr/bin/env python

from __future__ import print_function

import argparse
import errno
import os
import os.path
import pickle
import subprocess
import sys


def verify_initial(prefix):
    if not os.path.isdir(prefix):
        print('%s does not exist! wtf?!' % (prefix,))
        raise SystemExit(1)

    lib64 = os.path.join(prefix, 'lib64')
    lib32 = os.path.join(prefix, 'lib32')
    lib = os.path.join(prefix, 'lib')
    lib_new = os.path.join(prefix, 'lib.new')

    if not os.path.isdir(lib64) and not os.path.islink(lib64):
        print('%s needs to exist as a real directory!' % (lib64,), file=sys.stderr)
        raise SystemExit(1)

    if os.path.islink(lib32):
        print('%s is a symlink! was the migration done already?' % (lib32,), file=sys.stderr)
        raise SystemExit(1)

    if os.path.isdir(lib) and not os.path.islink(lib):
        print('%s is a real directory! was the migration done already?' % (lib,), file=sys.stderr)
        raise SystemExit(1)

    if os.path.islink(lib) and os.readlink(lib) == 'lib.new':
        print('%s is a symlink to lib.new! did you want to --finish?' % (lib,), file=sys.stderr)
        raise SystemExit(1)

    if not os.path.islink(lib) or os.readlink(lib) != 'lib64':
        print('%s needs to be a symlink to lib64!' % (lib,), file=sys.stderr)
        raise SystemExit(1)

    if os.path.isdir(lib_new):
        print('%s exists! do you need to remove failed migration?' % (lib_new,), file=sys.stderr)
        raise SystemExit(1)


def verify_migrated(prefix):
    if not os.path.isdir(prefix):
        print('%s does not exist! wtf?!' % (prefix,))
        raise SystemExit(1)

    lib64 = os.path.join(prefix, 'lib64')
    lib32 = os.path.join(prefix, 'lib32')
    lib = os.path.join(prefix, 'lib')
    lib_new = os.path.join(prefix, 'lib.new')

    if not os.path.isdir(lib64) and not os.path.islink(lib64):
        print('%s needs to exist as a real directory!' % (lib64,), file=sys.stderr)
        raise SystemExit(1)

    if os.path.islink(lib32):
        print('%s is a symlink! was the migration finished already?' % (lib32,), file=sys.stderr)
        raise SystemExit(1)

    if os.path.isdir(lib) and not os.path.islink(lib):
        print('%s is a real directory! was the migration finished already?' % (lib,), file=sys.stderr)
        raise SystemExit(1)

    if os.path.islink(lib) and os.readlink(lib) == 'lib64':
        print('%s is a symlink to lib64! did the migration succeed?' % (lib,), file=sys.stderr)
        raise SystemExit(1)

    if not os.path.isdir(lib_new):
        print('%s does not exist! did you --migrate?' % (lib_new,), file=sys.stderr)
        raise SystemExit(1)

    if not os.path.islink(lib) or os.readlink(lib) != 'lib.new':
        print('%s needs to be a symlink to lib.new!' % (lib,), file=sys.stderr)
        raise SystemExit(1)


def path_get_leftmost_dirs(paths):
    for p in paths:
        if '/' in p:
            yield p.split('/', 1)[0]


def path_get_top_files(paths):
    for p in paths:
        if '/' not in p:
            yield p


def path_starts_with(haystack, needle):
    return (haystack + '/').startswith(needle + '/')


def nonfatal_remove(fp):
    try:
        os.remove(fp)
    except OSError as e:
        if e.errno in (errno.EISDIR, errno.EPERM):
            try:
                os.rmdir(fp)
            except OSError as e:
                if e.errno not in (errno.EEXIST, errno.ENOTEMPTY):
                    print('Removing %s failed: %s' % (fp, e), file=sys.stderr)
                    return False
        elif e.errno == errno.ENOENT:
            pass
        else:
            print('Removing %s failed: %s' % (fp, e), file=sys.stderr)
            return False
    return True


def is_lib64_candidate(path):
    if os.path.splitext(path)[1] in ('.a', '.la', '.so'):
        return True
    if '.so.' in path:
        return True
    return False


class MigrationState(object):
    __slots__ = ('eroot', 'excludes', 'includes', 'prefixes', 'has_lib32')

    def __init__(self, eroot):
        self.eroot = eroot

    def analyze(self, usr_merge, real_prefixes):
        from portage import create_trees

        print('Analyzing files installed into lib & lib64...', file=sys.stderr)

        # use all canonical prefixes that could be present in vdb
        usr_prefix = os.path.join(self.eroot, 'usr')
        subprefixes = (
            self.eroot,
            usr_prefix,
            os.path.join(usr_prefix, 'local'),
        )

        lib_path = dict((prefix, os.path.join(prefix, 'lib/')) for prefix in subprefixes)
        lib32_path = dict((prefix, os.path.join(prefix, 'lib32/')) for prefix in subprefixes)
        lib64_path = dict((prefix, os.path.join(prefix, 'lib64/')) for prefix in subprefixes)

        lib_paths = dict((prefix, set()) for prefix in subprefixes)
        lib32_paths = dict((prefix, set()) for prefix in subprefixes)
        lib64_paths = dict((prefix, set()) for prefix in subprefixes)

        trees = create_trees(config_root=self.eroot)
        vardb = trees[max(trees)]['vartree'].dbapi
        missing_files = set()
        for p in vardb.cpv_all():
            for f, details in vardb._dblink(p).getcontents().items():
                # skip directories; we will get them implicitly via
                # files contained within them
                if details[0] == 'dir':
                    continue
                f = os.path.join(self.eroot, f.lstrip('/'))
                for prefix in subprefixes:
                    for libdir, dest in (
                            (lib_path[prefix], lib_paths[prefix]),
                            (lib32_path[prefix], lib32_paths[prefix]),
                            (lib64_path[prefix], lib64_paths[prefix])):
                        if f.startswith(libdir):
                            if not os.path.exists(f):
                                missing_files.add(f)
                            else:
                                dest.add(f[len(libdir):])
                            break

        pure_lib = {}
        mixed_lib = {}

        if usr_merge:
            print('', file=sys.stderr)
            print('/usr merge detected!', file=sys.stderr)

            # figure out which of the prefixes is real, and the other
            # will be the aliased one
            real_prefix = real_prefixes[0]
            if real_prefix == usr_prefix:
                alias_prefix = self.eroot
            else:
                alias_prefix = usr_prefix

            for d in lib_paths, lib32_paths, lib64_paths:
                d[real_prefix].update(d[alias_prefix])
                del d[alias_prefix]

        self.prefixes = real_prefixes
        self.excludes = {}
        self.includes = {}

        for prefix in real_prefixes:
            print('', file=sys.stderr)
            lib_paths[prefix] = frozenset(lib_paths[prefix])
            lib32_paths[prefix] = frozenset(lib32_paths[prefix])
            lib64_paths[prefix] = frozenset(lib64_paths[prefix])

            lib_prefixes = frozenset(path_get_leftmost_dirs(lib_paths[prefix]))
            lib64_prefixes = frozenset(path_get_leftmost_dirs(lib64_paths[prefix]))
            lib_files = frozenset(path_get_top_files(lib_paths[prefix]))
            lib64_files = frozenset(path_get_top_files(lib64_paths[prefix]))

            pure_lib = lib_prefixes - lib64_prefixes
            mixed_lib = lib_prefixes & lib64_prefixes

            unowned_files = (frozenset(os.listdir(lib_path[prefix]))
                             - lib_prefixes - lib64_prefixes
                             - lib_files - lib64_files)
            # library symlinks go to lib64
            lib64_unowned = frozenset(x for x in unowned_files
                                      if is_lib64_candidate(x))
            lib_unowned = unowned_files - lib64_unowned

            print('pure %s:' % (lib_path[prefix],), file=sys.stderr)
            for p in pure_lib:
                print('\t%s' % (p,), file=sys.stderr)
            print('\t(+ %d files)' % (len(lib_files),), file=sys.stderr)
            print('', file=sys.stderr)

            print('split %s+%s:' % (lib_path[prefix], lib64_path[prefix]), file=sys.stderr)
            for p in mixed_lib:
                print('\t%s' % (p,), file=sys.stderr)

            if lib_unowned:
                print('', file=sys.stderr)
                print('unowned files for %s:' % (lib_path[prefix],), file=sys.stderr)
                for p in lib_unowned:
                    print('\t%s' % (p,), file=sys.stderr)

            if lib64_unowned:
                print('', file=sys.stderr)
                print('unowned files for %s:' % (lib64_path[prefix],), file=sys.stderr)
                for p in lib64_unowned:
                    print('\t%s' % (p,), file=sys.stderr)

            # prepare the exclude lists
            excludes = set()
            for p in lib64_paths[prefix]:
                for tp in mixed_lib:
                    if path_starts_with(p, tp):
                        excludes.add(p)
                        break

            # store the data
            self.includes[prefix] = lib_prefixes | lib_files | lib_unowned
            self.excludes[prefix] = frozenset(excludes)

            # verify for conflicts
            conflicts = lib_paths[prefix] & lib32_paths[prefix]
            if conflicts:
                print('', file=sys.stderr)
                print('', file=sys.stderr)
                print('One or more files are both in %s&%s, making the conversion impossible.' % (
                    lib_path[prefix], lib32_path[prefix]), file=sys.stderr)
                print('', file=sys.stderr)
                for p in sorted(conflicts):
                    print('\t%s' % (p,), file=sys.stderr)
                print('', file=sys.stderr)
                print('Please report a bug at https://bugs.gentoo.org/, and do not proceed with', file=sys.stderr)
                print('the migration until a proper solution is found.', file=sys.stderr)
                raise SystemExit(1)

            conflicts = lib_paths[prefix] & lib64_paths[prefix]
            if conflicts:
                print('', file=sys.stderr)
                print('', file=sys.stderr)
                print('One or more files are both in %s&%s, making the conversion impossible.' % (
                    lib_path[prefix], lib64_path[prefix]), file=sys.stderr)
                print('', file=sys.stderr)
                for p in sorted(conflicts):
                    print('\t%s' % (p,), file=sys.stderr)
                print('', file=sys.stderr)
                print('Please report a bug at https://bugs.gentoo.org/, and do not proceed with', file=sys.stderr)
                print('the migration until a proper solution is found.', file=sys.stderr)
                raise SystemExit(1)

        self.has_lib32 = any(lib32_paths.values())
        if not self.has_lib32:
            print('', file=sys.stderr)
            print('', file=sys.stderr)
            print('Warning: no lib32 paths found. This is fine if you are running no-multilib,', file=sys.stderr)
            print('otherwise this is suspicious.', file=sys.stderr)

        if missing_files:
            print('', file=sys.stderr)
            print('', file=sys.stderr)
            print('One or more package files are missing from the system. This should not', file=sys.stderr)
            print('cause any problems but you may want to reinstall the packages', file=sys.stderr)
            print('that installed them. The missing files are:', file=sys.stderr)
            print('', file=sys.stderr)
            for p in sorted(missing_files):
                print('\t%s' % (p,), file=sys.stderr)

        # check for mountpoints, they are trouble
        mountpoints_staying = set()
        mountpoints_moved = set()
        for prefix in real_prefixes:
            for topdir in (lib64_path[prefix], lib32_path[prefix]):
                if not os.path.isdir(topdir):
                    continue
                for dirpath, dirnames, _ in os.walk(topdir):
                    for d in list(dirnames):
                        dp = os.path.join(dirpath, d)
                        if os.path.ismount(dp):
                            for x in self.includes[prefix]:
                                if path_starts_with(os.path.relpath(dp, topdir), x):
                                    mountpoints_moved.add(dp)
                                    break
                            else:
                                mountpoints_staying.add(dp)
                            # do not process filesystems recursively
                            dirnames.remove(d)

        if mountpoints_staying:
            print('', file=sys.stderr)
            print('', file=sys.stderr)
            print('One or more mount points (or subvolumes) detected:', file=sys.stderr)
            print('', file=sys.stderr)
            for p in sorted(mountpoints_staying):
                print('\t%s' % (p,), file=sys.stderr)
            print('', file=sys.stderr)
            print('Those directories do not need to be migrated. However, please make sure', file=sys.stderr)
            print('that fstab is using correct (real) paths to them.', file=sys.stderr)

        if mountpoints_moved:
            print('', file=sys.stderr)
            print('', file=sys.stderr)
            print('One or more mount points (or subvolumes) need to be migrated:', file=sys.stderr)
            print('', file=sys.stderr)
            for p in sorted(mountpoints_moved):
                print('\t%s' % (p,), file=sys.stderr)
            print('', file=sys.stderr)
            print('This script does not support migrating mount points at the moment. You can', file=sys.stderr)
            print('attempt a semi-manual migration or replace the mount point with a regular', file=sys.stderr)
            print('directory. In the former case, please compare the list of mount points', file=sys.stderr)
            print('against the planned moves printed above.', file=sys.stderr)
            print('', file=sys.stderr)
            print('1. If the mount point belongs to pure lib, it needs to be moved. The script', file=sys.stderr)
            print('will create an empty directory for it and you will need to remount it', file=sys.stderr)
            print('manually (or copy, in case of btrfs subvolume) and update fstab.', file=sys.stderr)
            print('', file=sys.stderr)
            print('2. If the mount point belongs to mixed lib+lib64, this scenario is currently', file=sys.stderr)
            print('unsupported and fully manual migration is necessary.', file=sys.stderr)
            print('', file=sys.stderr)
            print('Once you are ready to proceed, please unmount the filesystems and run', file=sys.stderr)
            print('--analyze again. In case of btrfs subvolumes, you will need to move', file=sys.stderr)
            print('the subvolume elsewhere, e.g. using snapshot+delete.', file=sys.stderr)
            raise SystemExit(1)

    def migrate(self, pretend):
        try:
            # create the lib.new directories
            for prefix in self.prefixes:
                lib = os.path.join(prefix, 'lib')
                lib32 = os.path.join(prefix, 'lib32')
                lib_new = os.path.join(prefix, 'lib.new')

                if pretend:
                    print('mkdir %s' % lib_new)
                else:
                    os.mkdir(lib_new)

                if not pretend:
                    print('[%s] & %s -> %s ...' % (lib32, lib, lib_new), file=sys.stderr)
                cmd = ['cp', '-a', '--reflink=auto', '--']
                if os.path.isdir(lib32):
                    cmd.append(os.path.join(lib32, '.'))
                # include all appropriate pure&mixed lib stuff
                for p in self.includes[prefix]:
                    assert not p.endswith('/')
                    cmd.append(os.path.join(lib, p))
                cmd.append(lib_new + '/')

                if len(cmd) > 5:
                    if pretend:
                        print(' '.join(cmd))
                    else:
                        p = subprocess.Popen(cmd)
                        if p.wait() != 0:
                            print('Non-successful return from cp: %d' % (p.returncode,), file=sys.stderr)
                            raise SystemExit(1)

                if self.excludes[prefix]:
                    if not pretend:
                        print('Remove extraneous files from %s ...' % (lib_new,), file=sys.stderr)
                    # remove excluded stuff
                    for p in self.excludes[prefix]:
                        fp = os.path.join(lib_new, p)
                        if pretend:
                            print('rm %s' % fp)
                            print('rmdir -p --ignore-fail-on-non-empty %s'
                                  % os.path.dirname(fp))
                        else:
                            os.unlink(fp)

                            try:
                                os.removedirs(os.path.dirname(fp))
                            except OSError as e:
                                if e.errno not in (errno.ENOTEMPTY, errno.EEXIST):
                                    raise
        except:
            print('', file=sys.stderr)
            print('An error occurred while creating the "lib.new" directories. Please look', file=sys.stderr)
            print('at the backtrace following this message for details. The partially', file=sys.stderr)
            print('created "lib.new" directories were left in case they were useful', file=sys.stderr)
            print('for determining the cause of the error.', file=sys.stderr)
            print('', file=sys.stderr)
            print('Once you determine the cause of the error and would like to retry,', file=sys.stderr)
            print('please use the --force-rollback action to reset your system.', file=sys.stderr)
            print('', file=sys.stderr)
            raise

        try:
            for prefix in self.prefixes:
                lib = os.path.join(prefix, 'lib')
                lib_tmp = os.path.join(prefix, 'lib.tmp')
                if pretend:
                    print('ln -s -f -T lib.new %s' % lib)
                else:
                    print('Updating: %s -> lib.new ...' % (lib,), file=sys.stderr)
                    os.symlink('lib.new', lib_tmp)
                    os.rename(lib_tmp, lib)
        except:
            print('', file=sys.stderr)
            print('An error occurred while updating the "lib" symlinks. Please look', file=sys.stderr)
            print('at the backtrace following this message for details. The "lib.new"', file=sys.stderr)
            print('directories are complete now but the "lib" symlinks were not updated', file=sys.stderr)
            print('completely.', file=sys.stderr)
            print('', file=sys.stderr)
            print('Once you determine the cause of the error and would like to retry,', file=sys.stderr)
            print('please use the --force-rollback action to reset your system.', file=sys.stderr)
            print('', file=sys.stderr)
            raise

    def rollback(self, pretend):
        try:
            # restore the old 'lib' symlink
            for prefix in self.prefixes:
                lib = os.path.join(prefix, 'lib')
                lib_tmp = os.path.join(prefix, 'lib.tmp')
                if pretend:
                    print('ln -s -f -T lib64 %s' % lib)
                else:
                    print('Updating: %s -> lib64 ...' % (lib,), file=sys.stderr)
                    os.symlink('lib64', lib_tmp)
                    os.rename(lib_tmp, lib)
        except:
            print('', file=sys.stderr)
            print('An error occurred while restoring the "lib" symlinks. Please look', file=sys.stderr)
            print('at the backtrace following this message for details.', file=sys.stderr)
            print('', file=sys.stderr)
            print('Once you determine the cause of the error and would like to retry,', file=sys.stderr)
            print('please use the --force-rollback action to reset your system.', file=sys.stderr)
            print('', file=sys.stderr)
            raise

        # clean up lib.new
        rm_failed = False
        for prefix in self.prefixes:
            lib_new = os.path.join(prefix, 'lib.new')
            if pretend:
                print('rm -rf -- %s' % lib_new)
            else:
                print('Removing: %s ...' % (lib_new,))
                p = subprocess.Popen(['rm', '-rf', '--', lib_new])
                if p.wait() != 0:
                    rm_failed = True

        if rm_failed:
            print('', file=sys.stderr)
            print('An error occurred while cleaning up the "lib.new" directories.', file=sys.stderr)
            print('This message should be preceded by error messages from the "rm"', file=sys.stderr)
            print('utility.')
            print('', file=sys.stderr)
            print('Once you determine the cause of the error and would like to retry,', file=sys.stderr)
            print('please use the --force-rollback action to reset your system.', file=sys.stderr)

    def finish(self, pretend, resume):
        try:
            # replace the 'lib' symlink with the directory
            for prefix in self.prefixes:
                lib = os.path.join(prefix, 'lib')
                lib_new = os.path.join(prefix, 'lib.new')
                # if lib.new does not exist, it has probably been moved already
                if resume and not os.path.isdir(lib_new):
                    continue
                if pretend:
                    print('mv -f -T %s %s' % (lib_new, lib))
                else:
                    print('Renaming %s -> %s ...' % (lib_new, lib), file=sys.stderr)
                    # when resuming, 'lib' may have already been unlinked
                    # (otherwise, it must exist at this point)
                    if not resume or os.path.islink(lib):
                        os.unlink(lib)
                    os.rename(lib_new, lib)
        except:
            print('', file=sys.stderr)
            print('An error occurred while replacing the "lib" symlinks. Please look', file=sys.stderr)
            print('at the backtrace following this message for details.', file=sys.stderr)
            print('', file=sys.stderr)
            print('Once you determine the cause of the error and would like to retry,', file=sys.stderr)
            print('please use the --resume-finish action.', file=sys.stderr)
            print('', file=sys.stderr)
            raise

        try:
            # replace 'lib32' with a symlink
            for prefix in self.prefixes:
                lib32 = os.path.join(prefix, 'lib32')
                if os.path.isdir(lib32):
                    # if resuming, it can be a symlink already
                    if resume and os.path.islink(lib32):
                        continue
                    if pretend:
                        print('rm -rf -- %s' % lib32)
                        print('ln -s lib %s' % lib32)
                    else:
                        print('Removing: %s ...' % (lib32,), file=sys.stderr)
                        if subprocess.Popen(['rm', '-rf', '--', lib32]).wait() != 0:
                            if os.path.ismount(lib32):
                                print('', file=sys.stderr)
                                print('Note: lib32 looks like a mount point. If all files inside it were removed', file=sys.stderr)
                                print('successfully, you need to unmount it to let the program replace it with', file=sys.stderr)
                                print('a symlink. You can remove or reuse the backing device afterwards.', file=sys.stderr)
                            raise SystemExit(1)
                        else:
                            print('Updating: %s -> lib ...' % (lib32,), file=sys.stderr)
                            try:
                                os.symlink('lib', lib32)
                            except OSError:
                                print('Symlinking failed for %s, please symlink it manually to lib.', file=sys.stderr)
        except:
            print('', file=sys.stderr)
            print('An error occurred while replacing the "lib32" directories. Please look', file=sys.stderr)
            print('at the backtrace following this message for details.', file=sys.stderr)
            print('', file=sys.stderr)
            print('Once you determine the cause of the error and would like to retry,', file=sys.stderr)
            print('please use the --resume-finish action.', file=sys.stderr)
            print('', file=sys.stderr)
            raise

        # clean up extraneous files from 'lib64'
        rm_failed = False
        for prefix in self.prefixes:
            lib64 = os.path.join(prefix, 'lib64')
            if not pretend:
                print('Removing stale files from %s ...' % (lib64,))
            for p in self.includes[prefix]:
                if not os.path.islink(os.path.join(lib64, p)):
                    for root, dirs, files in os.walk(os.path.join(lib64, p), topdown=False):
                        for f in dirs + files:
                            fp = os.path.join(root, f)
                            rp = os.path.relpath(fp, lib64)
                            if rp not in self.excludes[prefix]:
                                if pretend:
                                    print('rm -d %s' % fp)
                                elif not nonfatal_remove(fp):
                                    rm_failed = True
                if pretend:
                    print('rm -d %s' % os.path.join(lib64, p))
                elif not nonfatal_remove(os.path.join(lib64, p)):
                    rm_failed = True

        if rm_failed:
            print('', file=sys.stderr)
            print('An error occurred while cleaning up the "lib64" directories.', file=sys.stderr)
            print('This message should be preceded by more specific error messages', file=sys.stderr)
            print('(interspersed with progress output).')
            print('', file=sys.stderr)
            print('Once you determine the cause of the error and would like to retry,', file=sys.stderr)
            print('please use the --resume-finish action.', file=sys.stderr)
            raise SystemExit(1)

    def save_state(self):
        with open(os.path.expanduser('~/.symlink_lib_migrate.state'), 'wb') as f:
            pickle.dump((self.eroot, self.prefixes, self.excludes, self.includes, self.has_lib32), f)

    def load_state(self):
        try:
            with open(os.path.expanduser('~/.symlink_lib_migrate.state'), 'rb') as f:
                orig_eroot, self.prefixes, self.excludes, self.includes, self.has_lib32 = pickle.load(f)
        except (OSError, IOError) as e:
            if e.errno == errno.ENOENT:
                return False
            else:
                raise

        if self.eroot != orig_eroot:
            raise NotImplementedError('The same --root must be passed to each invocation')

        return True

    def clear_state(self):
        try:
            os.unlink(os.path.expanduser('~/.symlink_lib_migrate.state'))
        except OSError as e:
            if e.errno != errno.ENOENT:
                raise


def main():
    argp = argparse.ArgumentParser()
    argp.add_argument('-p', '--pretend', action='store_true',
                      help='Do not modify the system, only print what would happen')
    argp.add_argument('--root', default='/',
                      help='Run on specified alternate system root')
    g = argp.add_argument_group('basic actions')
    g.add_argument('--analyze', action='store_const', dest='action',
                   const='analyze', help='Analyze and store system state',
                   default='analyze')
    g.add_argument('--migrate', action='store_const', dest='action',
                   const='migrate', help='Perform the migration')
    g.add_argument('--rollback', action='store_const', dest='action',
                   const='rollback', help='Revert the migration (after --migrate)')
    g.add_argument('--finish', action='store_const', dest='action',
                   const='finish', help='Finish the migration (clean up)')
    g = argp.add_argument_group('recovery actions (NO SAFETY!)')
    g.add_argument('--force-rollback', action='store_const', dest='action',
                   const='rollback_force',
                   help='Force resetting "lib" symlink and removing "lib.new"')
    g.add_argument('--resume-finish', action='store_const', dest='action',
                   const='finish_resume',
                   help='Attempt resuming failed --finish action')
    g = argp.add_argument_group('expert options')
    g.add_argument('-P', '--prefix',
                   help='Migrate only the specified prefix directory (EXPERT)')
    args = argp.parse_args()

    is_root = os.geteuid() == 0

    if not is_root:
        if args.action != 'analyze':
            argp.error('Requested action requires root privileges')
        else:
            print('[Running as unprivileged user, results will not be saved]',
                  file=sys.stderr)

    top_dir = args.root

    if args.prefix:
        usr_merge = False
        prefixes = [args.prefix]
    else:
        # helpful consts
        usr_dir = os.path.join(top_dir, 'usr')
        lib64_dir = os.path.join(top_dir, 'lib64')
        usr_lib64_dir = os.path.join(usr_dir, 'lib64')

        # if /lib64 and /usr/lib64 are the same directory, we're dealing
        # with /usr merge most likely
        if os.path.samefile(lib64_dir, usr_lib64_dir):
            usr_merge = True
            # use whichever prefix has the real directories
            if not os.path.islink(lib64_dir):
                prefixes = [top_dir]
            else:
                prefixes = [usr_dir]
        else:
            usr_merge = False
            prefixes = [top_dir, usr_dir]

        # add /usr/local too
        prefixes.append(os.path.join(usr_dir, 'local'))

    if args.action == 'analyze':
        for p in prefixes:
            verify_initial(p)

        m = MigrationState(top_dir)
        m.analyze(usr_merge, prefixes)

        # safety check
        assert m.prefixes == prefixes

        if is_root:
            m.save_state()
            print('', file=sys.stderr)
            print('', file=sys.stderr)
            print('The state has been saved and the migration is ready to proceed.', file=sys.stderr)
            print('To initiate it, please run:', file=sys.stderr)
            print('', file=sys.stderr)
            print('\t%s --migrate' % (sys.argv[0],), file=sys.stderr)
            print('', file=sys.stderr)
            print('Please do not perform any changes to the system at this point.', file=sys.stderr)
            print('If you performed any changes, please rerun the analysis.', file=sys.stderr)
        else:
            print('', file=sys.stderr)
            print('', file=sys.stderr)
            print('Everything looks good from here. However, you need to rerun', file=sys.stderr)
            print('the process as root to confirm.', file=sys.stderr)
    elif args.action == 'migrate':
        for p in prefixes:
            verify_initial(p)

        m = MigrationState(top_dir)
        if not m.load_state():
            print('State file could not be loaded. Did you run --analyze?', file=sys.stderr)
            return 1
        if args.pretend:
            print('Those are the actions that would be performed:', file=sys.stderr)
        m.migrate(pretend=args.pretend)
        if not args.pretend:
            print('', file=sys.stderr)
            print('', file=sys.stderr)
            print('Initial migration complete. Please now test whether your system works', file=sys.stderr)
            print('correctly. It might be a good idea to try rebooting it. Once tested,', file=sys.stderr)
            print('complete the migration and clean up backup files via calling:', file=sys.stderr)
            print('', file=sys.stderr)
            print('\t%s --finish' % (sys.argv[0],), file=sys.stderr)
            print('', file=sys.stderr)
            print('If you wish to revert the changes, run:', file=sys.stderr)
            print('', file=sys.stderr)
            print('\t%s --rollback' % (sys.argv[0],), file=sys.stderr)
    elif args.action.startswith('rollback'):
        if not args.action.endswith('force'):
            for p in prefixes:
                verify_migrated(p)

        m = MigrationState(top_dir)
        if not m.load_state():
            print('State file could not be loaded. Did you run --analyze?', file=sys.stderr)
            return 1
        if args.pretend:
            print('Those are the actions that would be performed:', file=sys.stderr)
        m.rollback(pretend=args.pretend)
        if not args.pretend:
            m.clear_state()
            print('', file=sys.stderr)
            print('', file=sys.stderr)
            print('Rollback complete. Your system should now be as before the migration.', file=sys.stderr)
            print('Please look into fixing your issues and try again.', file=sys.stderr)
    elif args.action.startswith('finish'):
        if not args.action.endswith('resume'):
            for p in prefixes:
                verify_migrated(p)

        m = MigrationState(top_dir)
        if not m.load_state():
            print('State file could not be loaded. Did you run --analyze?', file=sys.stderr)
            return 1
        if args.pretend:
            print('Those are the actions that would be performed:', file=sys.stderr)
        m.finish(pretend=args.pretend, resume=args.action.endswith('resume'))
        if not args.pretend:
            m.clear_state()
            print('', file=sys.stderr)
            print('', file=sys.stderr)
            print('Migration complete. Please switch to the new profiles, or add', file=sys.stderr)
            print('the following to your make.conf (or equivalent):', file=sys.stderr)
            print('', file=sys.stderr)
            print('\tSYMLINK_LIB=no', file=sys.stderr)
            if m.has_lib32:
                print('\tLIBDIR_x86=lib', file=sys.stderr)
            print('', file=sys.stderr)
            print('Afterwards, please rebuild all installed GCC versions', end='', file=sys.stderr)
            if m.has_lib32:
                print(' and all\npackages installing into lib32', end='', file=sys.stderr)
            print(', e.g.:', file=sys.stderr)
            print('', file=sys.stderr)
            print('\temerge -1v %s' % os.path.join(top_dir, 'usr/lib/gcc'), end='', file=sys.stderr)
            if m.has_lib32:
                print(' %s %s' % (os.path.join(top_dir, 'lib32'),
                                  os.path.join(top_dir, 'usr/lib32')),
                      end='', file=sys.stderr)
            print('', file=sys.stderr)
            if m.has_lib32:
                print('', file=sys.stderr)
                print('When the rebuilds are complete, the package manager should remove', file=sys.stderr)
                print('the lib32 symlink. If it does not, do:', file=sys.stderr)
                print('', file=sys.stderr)
                print('\trm %s %s' % (os.path.join(top_dir, 'lib32'),
                                      os.path.join(top_dir, 'usr/lib32')),
                      file=sys.stderr)
    else:
        raise NotImplementedError()


if __name__ == '__main__':
    main()
